{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Read Latest Documentation - Browse GitHub Code Repository The only thing worse than documentation never written, is documentation written but never discovered. portray is a Python3 command line tool and library that helps you create great documentation websites for your Python projects with as little effort as possible. Key Features: Zero-Config : No configuration is necessary to use portray . Just run portray in the root of your Python project and it will find your documentation. Statically Generated : portray websites are easy to host on GitHub pages and other similar services as they are outputted as standard static HTML websites. Markdown Aware : portray will automatically include your projects .md files and render them into HTML. It will also find and render Markdown within __doc__ strings. Fully Configurable : While portray doesn't have to be configured, you still can fully configure it within the standard pyproject.toml file. Easily Programmable : portray exposes a clean and simple Python API . Searchable : Out of the box portray makes all of your documentation, even autogenerated code references, free-text searchable. Themeable : portray is compatible with all existing MkDocs Themes . Under the hood, portray combines the Markdown documentation rendering capabilities provided by MkDocs with the automatic reference documentation generated by pdocs . Quick Start The following guides should get you up and running with a documentation website in no time. Installation - TL;DR: Run pip3 install portray within your projects virtual environment. Command Line Usage - TL;DR: Run portray in_browser to test and portray on_github_pages to deploy. API Usage - TL;DR: Everything available via the CLI is also easily available programmatically from within Python. Configuration - TL;DR: Put all configuration within a [tool.portray] section of your pyproject.toml file. Why Create Portray? I create a lot of Python projects and I've always wanted a quick way to build documentation sites for them that included both manually written guides and autogenerated reference documentation. Tools have improved over the years, but still nothing has given me this experience out of the box. Portray isn't a competitor for the 2 newer Python documentation projects (pdocs and MkDocs), rather it is melding of them together to give me the quick to create and comprehensive documentation website generation I've always wanted. Thanks and I hope you too find portray useful! ~Timothy Crosley","title":"Home"},{"location":"#quick-start","text":"The following guides should get you up and running with a documentation website in no time. Installation - TL;DR: Run pip3 install portray within your projects virtual environment. Command Line Usage - TL;DR: Run portray in_browser to test and portray on_github_pages to deploy. API Usage - TL;DR: Everything available via the CLI is also easily available programmatically from within Python. Configuration - TL;DR: Put all configuration within a [tool.portray] section of your pyproject.toml file.","title":"Quick Start"},{"location":"#why-create-portray","text":"I create a lot of Python projects and I've always wanted a quick way to build documentation sites for them that included both manually written guides and autogenerated reference documentation. Tools have improved over the years, but still nothing has given me this experience out of the box. Portray isn't a competitor for the 2 newer Python documentation projects (pdocs and MkDocs), rather it is melding of them together to give me the quick to create and comprehensive documentation website generation I've always wanted. Thanks and I hope you too find portray useful! ~Timothy Crosley","title":"Why Create Portray?"},{"location":"CHANGELOG/","text":"Install the latest To install the latest version of portray simply run: pip3 install portray OR poetry add portray OR pipenv install portray see the Installation QuickStart for more instructions. Changelog 1.2.1 - September 3 2019 General improvements to reference code documentation rendering 1.2.0 - September 3 2019 Potentially breaking dependency change release from pdoc3 to pdocs . Migration guide: pyproject.toml config section changes from [tool.portray.pdoc3] to [tool.portray.pdocs] Type annotations are no longer toggleable but are rather always on. 1.1.0 - August 29 2019 Minor Feature release w/ Bug Fixes Added support for specifying modules directly from the CLI and API. Added auto module detect for simple setup.py files. Improved CLI subcommand documentation. Implemented Issue 12 - Clarify what a \"project\" is in documentation. Fixed Issue 2 - UnicodeEncodeError except when running portray. Fixed Issue 10 - Class methods rendered incorrectly. Fixed Issue 17 - Portray silently requires README.md file. 1.0.5 - August 26 PM 2019 Bug fix release Fixed Issue 6 - Failed to open web-browser on startup. Fixed Issue 5 - Some links are missing a trailing slash. Fixed Issue 4 - Class references generate large code block. Big thanks to Marcel Hellkamp ( @defnull ) for fixing these issues. 1.0.0 - August 26 AM 2019 Initial API stable release of portray","title":"Changelog"},{"location":"CHANGELOG/#install-the-latest","text":"To install the latest version of portray simply run: pip3 install portray OR poetry add portray OR pipenv install portray see the Installation QuickStart for more instructions.","title":"Install the latest"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#121-september-3-2019","text":"General improvements to reference code documentation rendering","title":"1.2.1 - September 3 2019"},{"location":"CHANGELOG/#120-september-3-2019","text":"Potentially breaking dependency change release from pdoc3 to pdocs .","title":"1.2.0 - September 3 2019"},{"location":"CHANGELOG/#migration-guide","text":"pyproject.toml config section changes from [tool.portray.pdoc3] to [tool.portray.pdocs] Type annotations are no longer toggleable but are rather always on.","title":"Migration guide:"},{"location":"CHANGELOG/#110-august-29-2019","text":"Minor Feature release w/ Bug Fixes Added support for specifying modules directly from the CLI and API. Added auto module detect for simple setup.py files. Improved CLI subcommand documentation. Implemented Issue 12 - Clarify what a \"project\" is in documentation. Fixed Issue 2 - UnicodeEncodeError except when running portray. Fixed Issue 10 - Class methods rendered incorrectly. Fixed Issue 17 - Portray silently requires README.md file.","title":"1.1.0 - August 29 2019"},{"location":"CHANGELOG/#105-august-26-pm-2019","text":"Bug fix release Fixed Issue 6 - Failed to open web-browser on startup. Fixed Issue 5 - Some links are missing a trailing slash. Fixed Issue 4 - Class references generate large code block. Big thanks to Marcel Hellkamp ( @defnull ) for fixing these issues.","title":"1.0.5 - August 26 PM 2019"},{"location":"CHANGELOG/#100-august-26-am-2019","text":"Initial API stable release of portray","title":"1.0.0 - August 26 AM 2019"},{"location":"TROUBLESHOOTING/","text":"Troubleshooting / FAQ Guide As common issues or questions are encountered solutions will be added to this guide. NoProjectFound portray raises this exception when it cant find a project in the current directory. This means that there is no pyproject.toml or setup.py file in the directory you ran portray AND that you haven't specified modules to include on the command line. Solution 1: Go to root of project If you do have a pyproject.toml or setup.py file in your project, chances are you simply accidentally ran portray from a different directory. Simply changing back to your projects root directory at the same level as these files should be enough to resolve your issue. Solution 2: Create a pyproject.toml file You can create a simplified pyproject.toml file that explicitly specifies what modules are included in your project: [tool.portray] modules = [\"MY_MODULE\"] Solution 3: Specify the modules manually from the command line Every CLI command supports explicitly setting one or more modules using -m : Deploying to Netlify portray includes a built-in command to deploy to Github Pages but it's also compatible with every static website host, including the popular Netflify . There's a great guide on how to set this up contributed by @sw-yx here .","title":"Troubleshooting"},{"location":"TROUBLESHOOTING/#troubleshooting-faq-guide","text":"As common issues or questions are encountered solutions will be added to this guide.","title":"Troubleshooting / FAQ Guide"},{"location":"TROUBLESHOOTING/#noprojectfound","text":"portray raises this exception when it cant find a project in the current directory. This means that there is no pyproject.toml or setup.py file in the directory you ran portray AND that you haven't specified modules to include on the command line.","title":"NoProjectFound"},{"location":"TROUBLESHOOTING/#solution-1-go-to-root-of-project","text":"If you do have a pyproject.toml or setup.py file in your project, chances are you simply accidentally ran portray from a different directory. Simply changing back to your projects root directory at the same level as these files should be enough to resolve your issue.","title":"Solution 1: Go to root of project"},{"location":"TROUBLESHOOTING/#solution-2-create-a-pyprojecttoml-file","text":"You can create a simplified pyproject.toml file that explicitly specifies what modules are included in your project: [tool.portray] modules = [\"MY_MODULE\"]","title":"Solution 2: Create a pyproject.toml file"},{"location":"TROUBLESHOOTING/#solution-3-specify-the-modules-manually-from-the-command-line","text":"Every CLI command supports explicitly setting one or more modules using -m :","title":"Solution 3: Specify the modules manually from the command line"},{"location":"TROUBLESHOOTING/#deploying-to-netlify","text":"portray includes a built-in command to deploy to Github Pages but it's also compatible with every static website host, including the popular Netflify . There's a great guide on how to set this up contributed by @sw-yx here .","title":"Deploying to Netlify"},{"location":"docs/contributing/1.-contributing-guide/","text":"Contributing to portray Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place. Getting portray set up for local development The first step when contributing to any project is getting it set up on your local machine. portray aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/portray.git `cd portray poetry install Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main portray project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :). Thank you! I can not tell you how thankful I am for the hard work done by portray contributors like you . Thank you! ~Timothy Crosley","title":"1. Contributing Guide"},{"location":"docs/contributing/1.-contributing-guide/#contributing-to-portray","text":"Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place.","title":"Contributing to portray"},{"location":"docs/contributing/1.-contributing-guide/#getting-portray-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. portray aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/portray.git `cd portray poetry install","title":"Getting portray set up for local development"},{"location":"docs/contributing/1.-contributing-guide/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main portray project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :).","title":"Making a contribution"},{"location":"docs/contributing/1.-contributing-guide/#thank-you","text":"I can not tell you how thankful I am for the hard work done by portray contributors like you . Thank you! ~Timothy Crosley","title":"Thank you!"},{"location":"docs/contributing/2.-coding-standard/","text":"HOPE 8 -- Style Guide for Hug Code HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019 Introduction This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference. PEP 8 Foundation All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines. Line Length Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters. Descriptive Variable names Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand. Adding new modules New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible. Automated Code Cleaners All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place. Automated Code Linting All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"2. Coding Standard"},{"location":"docs/contributing/2.-coding-standard/#hope-8-style-guide-for-hug-code","text":"HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019","title":"HOPE 8 -- Style Guide for Hug Code"},{"location":"docs/contributing/2.-coding-standard/#introduction","text":"This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference.","title":"Introduction"},{"location":"docs/contributing/2.-coding-standard/#pep-8-foundation","text":"All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines.","title":"PEP 8 Foundation"},{"location":"docs/contributing/2.-coding-standard/#line-length","text":"Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters.","title":"Line Length"},{"location":"docs/contributing/2.-coding-standard/#descriptive-variable-names","text":"Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand.","title":"Descriptive Variable names"},{"location":"docs/contributing/2.-coding-standard/#adding-new-modules","text":"New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Adding new modules"},{"location":"docs/contributing/2.-coding-standard/#automated-code-cleaners","text":"All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place.","title":"Automated Code Cleaners"},{"location":"docs/contributing/2.-coding-standard/#automated-code-linting","text":"All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"Automated Code Linting"},{"location":"docs/contributing/3.-code-of-conduct/","text":"HOPE 11 -- Code of Conduct HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019 Abstract Defines the Code of Conduct for Hug and all related projects. Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"3. Code Of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#hope-11-code-of-conduct","text":"HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019","title":"HOPE 11 -- Code of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#abstract","text":"Defines the Code of Conduct for Hug and all related projects.","title":"Abstract"},{"location":"docs/contributing/3.-code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"docs/contributing/3.-code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/contributing/3.-code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"docs/contributing/3.-code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"docs/contributing/3.-code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"docs/contributing/3.-code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"docs/contributing/4.-acknowledgements/","text":"Contributors Core Developers Timothy Edmund Crosley (@timothycrosley) Notable Bug Reporters - Code Contributors Marcel Hellkamp (@defnull) Zach Valenta (@zachvalenta) Documenters Arman Ashrafian (@arman-ashrafian) A sincere thanks to everyone who helps make portray into a great Python3 project! ~Timothy Crosley","title":"4. Acknowledgements"},{"location":"docs/contributing/4.-acknowledgements/#contributors","text":"","title":"Contributors"},{"location":"docs/contributing/4.-acknowledgements/#core-developers","text":"Timothy Edmund Crosley (@timothycrosley)","title":"Core Developers"},{"location":"docs/contributing/4.-acknowledgements/#notable-bug-reporters","text":"-","title":"Notable Bug Reporters"},{"location":"docs/contributing/4.-acknowledgements/#code-contributors","text":"Marcel Hellkamp (@defnull) Zach Valenta (@zachvalenta)","title":"Code Contributors"},{"location":"docs/contributing/4.-acknowledgements/#documenters","text":"Arman Ashrafian (@arman-ashrafian) A sincere thanks to everyone who helps make portray into a great Python3 project! ~Timothy Crosley","title":"Documenters"},{"location":"docs/quick_start/1.-installation/","text":"Install portray into your projects virtual environment: pip3 install portray OR poetry add portray OR pipenv install portray Always run portray within the root of your project directory or specify a project directory from the command line using --directory . Info It's important that portray be installed in your project's environment as it needs to introspect your package to generate reference documentation. You must also have your project installed in the environment for this to work.","title":"1. Installation"},{"location":"docs/quick_start/2.-cli/","text":"Command Line Usage Once installed, portray exposes a simple command line utility for generating documentation websites. To verify the tool is installed correctly, run portray from the command line and you should be given the available commands and the version of portray installed. To get help for any individual subcommand run portray SUBCOMMAND --help : Serving Documentation Locally Before you push documentation out publicly, it's a good idea to test it locally and ensure it looks as desired. Running portray server will generate a new static website for your project in a temporary directory and start a local server to allow you to browse it (at localhost:8000 by default). Running portray in_browser will do the same as portray server but also open up the generated website in your environments default web browser for you. Both commands take an optional --port and --host argument. Tip portray does its best to auto determine package modules in order to generate documentation. It does this by looking at pyproject.toml and your directory name. If it can't auto determine the Python modules used by your project, you can set them manually in your pyproject.toml file: [tool.portray] modules = [\"portray\"] Or, if you want to avoid configuration files entirely, you can set modules explicitly on the command line using -m (Example: portray server -m portray .) Finally, portray pulls .md files from the root of your project and one dedicated documentation directory (defaulting to docs ) by default. You can change the directory where docs are located by setting the tool.portray.docs_dir setting in pyproject.toml . Outputting Documentation Locally You can also output portray 's generated documentation to a local directory. To do so run portray as_html : By default the generated documentation is outputted into a site subdirectory. If this directory exists for any reason, including previous documentation generation, the command will fail. Passing in --overwrite will delete any existing directory before output to ensure the command passes. You can change the output directory using -o DIRECTORY . Pushing Documentation to GitHub Pages If you are using GitHub Pages to share your generated documentation you can use portray on_github_pages to automate the process: Verifying Project Configuration You can verify the configuration auto determined by portray using portray project_configuration in the root of your project: If anything seems incorrect, or you would want to modify any values, you can override any config option by setting it in the [tool.portray] section of your pyproject.toml file.","title":"2. Cli"},{"location":"docs/quick_start/2.-cli/#command-line-usage","text":"Once installed, portray exposes a simple command line utility for generating documentation websites. To verify the tool is installed correctly, run portray from the command line and you should be given the available commands and the version of portray installed. To get help for any individual subcommand run portray SUBCOMMAND --help :","title":"Command Line Usage"},{"location":"docs/quick_start/2.-cli/#serving-documentation-locally","text":"Before you push documentation out publicly, it's a good idea to test it locally and ensure it looks as desired. Running portray server will generate a new static website for your project in a temporary directory and start a local server to allow you to browse it (at localhost:8000 by default). Running portray in_browser will do the same as portray server but also open up the generated website in your environments default web browser for you. Both commands take an optional --port and --host argument. Tip portray does its best to auto determine package modules in order to generate documentation. It does this by looking at pyproject.toml and your directory name. If it can't auto determine the Python modules used by your project, you can set them manually in your pyproject.toml file: [tool.portray] modules = [\"portray\"] Or, if you want to avoid configuration files entirely, you can set modules explicitly on the command line using -m (Example: portray server -m portray .) Finally, portray pulls .md files from the root of your project and one dedicated documentation directory (defaulting to docs ) by default. You can change the directory where docs are located by setting the tool.portray.docs_dir setting in pyproject.toml .","title":"Serving Documentation Locally"},{"location":"docs/quick_start/2.-cli/#outputting-documentation-locally","text":"You can also output portray 's generated documentation to a local directory. To do so run portray as_html : By default the generated documentation is outputted into a site subdirectory. If this directory exists for any reason, including previous documentation generation, the command will fail. Passing in --overwrite will delete any existing directory before output to ensure the command passes. You can change the output directory using -o DIRECTORY .","title":"Outputting Documentation Locally"},{"location":"docs/quick_start/2.-cli/#pushing-documentation-to-github-pages","text":"If you are using GitHub Pages to share your generated documentation you can use portray on_github_pages to automate the process:","title":"Pushing Documentation to GitHub Pages"},{"location":"docs/quick_start/2.-cli/#verifying-project-configuration","text":"You can verify the configuration auto determined by portray using portray project_configuration in the root of your project: If anything seems incorrect, or you would want to modify any values, you can override any config option by setting it in the [tool.portray] section of your pyproject.toml file.","title":"Verifying Project Configuration"},{"location":"docs/quick_start/3.-api/","text":"Programmatic Python API Usage Every command available from the command line utility is also available directly as function calls within Python. To use the Python API, import portray and then call the desired function call: Every function is type hinted and takes and returns only builtin Python objects. For a full definition of the API see the API reference documentation .","title":"3. Api"},{"location":"docs/quick_start/3.-api/#programmatic-python-api-usage","text":"Every command available from the command line utility is also available directly as function calls within Python. To use the Python API, import portray and then call the desired function call: Every function is type hinted and takes and returns only builtin Python objects. For a full definition of the API see the API reference documentation .","title":"Programmatic Python API Usage"},{"location":"docs/quick_start/4.-configuration/","text":"Configuring portray Hopefully, portray 's automatic configuration will pick up everything you need to document your project. If not, portray enables configuration for every aspect of your documentation website using Python's standard pyproject.toml file. Configuration options should be placed within a tool.poetry section of your config file: [tool.portray] output_dir = \"documentation_website\" portray itself comes with a handful of configuration options: docs_dir : The directory (beyond your project root directory) where your markdown documentation is located. Defaults to \"docs\" . output_dir : The directory to output your generated documentation website when using portray as_html . Defaults to \"site\" . port : The port to use when serving your website locally. Defaults to 8000 . host : The host to use when serving your website locally. Defaults to 127.0.0.1 . labels : Label remappings for documentation pages. modules : A List of Python modules to generate reference documentation for. Beyond portray's direct configuration options, you can modify any of MkDocs or pdocs configuration options in the same pyproject.yaml file. Simply nest their documentation under a .mkdocs or .pdoc3 . For example, to change the MkDocs theme configuration used for portray the following is set in pyproject.toml : [tool.portray.mkdocs.theme] favicon = \"art/logo_small.png\" logo = \"art/logo_small.png\" name = \"material\" palette = { primary = \"blue grey\" , accent = \"pink\" } For more information see MkDocs configuration and pdoc3 configuration . Warning While portray allows configuring any aspect of MkDocs or pdoc3, it only allows that configuration to be defined in a pyproject.toml file. Any other configuration files normally used for these projects will be ignored.","title":"4. Configuration"},{"location":"docs/quick_start/4.-configuration/#configuring-portray","text":"Hopefully, portray 's automatic configuration will pick up everything you need to document your project. If not, portray enables configuration for every aspect of your documentation website using Python's standard pyproject.toml file. Configuration options should be placed within a tool.poetry section of your config file: [tool.portray] output_dir = \"documentation_website\" portray itself comes with a handful of configuration options: docs_dir : The directory (beyond your project root directory) where your markdown documentation is located. Defaults to \"docs\" . output_dir : The directory to output your generated documentation website when using portray as_html . Defaults to \"site\" . port : The port to use when serving your website locally. Defaults to 8000 . host : The host to use when serving your website locally. Defaults to 127.0.0.1 . labels : Label remappings for documentation pages. modules : A List of Python modules to generate reference documentation for. Beyond portray's direct configuration options, you can modify any of MkDocs or pdocs configuration options in the same pyproject.yaml file. Simply nest their documentation under a .mkdocs or .pdoc3 . For example, to change the MkDocs theme configuration used for portray the following is set in pyproject.toml : [tool.portray.mkdocs.theme] favicon = \"art/logo_small.png\" logo = \"art/logo_small.png\" name = \"material\" palette = { primary = \"blue grey\" , accent = \"pink\" } For more information see MkDocs configuration and pdoc3 configuration . Warning While portray allows configuring any aspect of MkDocs or pdoc3, it only allows that configuration to be defined in a pyproject.toml file. Any other configuration files normally used for these projects will be ignored.","title":"Configuring portray"},{"location":"reference/portray/","text":"Module portray View Source from portray._version import __version__ from portray.api import as_html , in_browser , on_github_pages , project_configuration , server Sub-modules portray.api portray.cli portray.config portray.exceptions portray.logo portray.render","title":"Index"},{"location":"reference/portray/#module-portray","text":"View Source from portray._version import __version__ from portray.api import as_html , in_browser , on_github_pages , project_configuration , server","title":"Module portray"},{"location":"reference/portray/#sub-modules","text":"portray.api portray.cli portray.config portray.exceptions portray.logo portray.render","title":"Sub-modules"},{"location":"reference/portray/api/","text":"Module portray.api This module defines the programmatic API that can be used to interact with portray to generate and view documentation. If you want to extend portray or use it directly from within Python - this is the place to start. View Source \"\"\"This module defines the programmatic API that can be used to interact with `portray` to generate and view documentation. If you want to extend `portray` or use it directly from within Python - this is the place to start. \"\"\" import os import webbrowser from typing import Optional import hug import mkdocs.commands.gh_deploy from portray import config , logo , render def as_html ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , output_dir : str = \"site\" , overwrite : bool = False , modules : list = None , ) -> None : \"\"\"Produces HTML documentation for a Python project placing it into output_dir. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *output_dir*: The directory to place the generated HTML into. - *overwrite*: If set to `True` any existing documentation output will be removed before generating new documentation. Otherwise, if documentation exists in the specified `output_dir` the command will fail with a `DocumentationAlreadyExists` exception. - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () render . documentation ( project_configuration ( directory , config_file , modules ), overwrite = overwrite ) print ( logo . ascii_art ) print ( \"Documentation successfully generated into `{}` !\" . format ( os . path . abspath ( output_dir ))) def in_browser ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , port : int = None , host : str = None , modules : list = None , ) -> None : \"\"\"Opens your default webbrowser pointing to a locally started development webserver enabling you to browse documentation locally - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\"127.0.0.1\"`) - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () server ( directory = directory , config_file = config_file , open_browser = True , modules = modules ) def server ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , open_browser : bool = False , port : int = None , host : str = None , modules : list = None , ) -> None : \"\"\"Runs a development webserver enabling you to browse documentation locally. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *open_browser\": If true a browser will be opened pointing at the documentation server - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\"127.0.0.1\"`) - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () api = hug . API ( \"Doc Server\" ) project_config = project_configuration ( directory , config_file , modules ) with render . documentation_in_temp_folder ( project_config ) as doc_folder : @hug.static ( \"/\" , api = api ) def my_static_dirs (): # pragma: no cover return ( doc_folder ,) @hug.startup ( api = api ) def custom_startup ( * args , ** kwargs ): # pragma: no cover print ( logo . ascii_art ) if open_browser : webbrowser . open_new ( \"http://{}:{}\" . format ( project_config [ \"host\" ], project_config [ \"port\" ]) ) api . http . serve ( host = host or project_config [ \"host\" ], port = port or project_config [ \"port\" ], no_documentation = True , display_intro = False , ) def project_configuration ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , modules : list = None ) -> dict : \"\"\"Returns the configuration associated with a project. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *modules*: One or more modules to include in the configuration for reference rendering \"\"\" overrides = {} if modules : overrides [ \"modules\" ] = modules directory = directory if directory else os . getcwd () return config . project ( directory = directory , config_file = config_file , ** overrides ) def on_github_pages ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , message : str = None , force : bool = False , ignore_version : bool = False , modules : list = None , ) -> None : \"\"\"Regenerates and deploys the documentation to GitHub pages. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *message*: The commit message to use when uploading your documentation. - *force*: Force the push to the repository. - *ignore_version*: Ignore check that build is not being deployed with an old version. - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () project_config = project_configuration ( directory , config_file , modules ) with render . documentation_in_temp_folder ( project_config ): conf = render . _mkdocs_config ( project_config [ \"mkdocs\" ]) conf . config_file_path = directory mkdocs . commands . gh_deploy . gh_deploy ( conf , message = message , force = force , ignore_version = ignore_version ) print ( logo . ascii_art ) print ( \"Documentation successfully generated and pushed!\" ) Functions as_html def as_html ( directory : str = '' , config_file : str = 'pyproject.toml' , output_dir : str = 'site' , overwrite : bool = False , modules : list = None ) -> None Produces HTML documentation for a Python project placing it into output_dir. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. output_dir : The directory to place the generated HTML into. overwrite : If set to True any existing documentation output will be removed before generating new documentation. Otherwise, if documentation exists in the specified output_dir the command will fail with a DocumentationAlreadyExists exception. modules : One or more modules to render reference documentation for View Source def as_html ( directory : str = \"\" , config_file : str = \" pyproject.toml \" , output_dir : str = \" site \" , overwrite : bool = False , modules : list = None , ) -> None : \"\"\" Produces HTML documentation for a Python project placing it into output_dir. - * directory * : The root folder of your project . - * config_file * : The [ TOML ] ( https : // github . com / toml - lang / toml # toml ) formatted config file you wish to use . - * output_dir * : The directory to place the generated HTML into . - * overwrite * : If set to ` True ` any existing documentation output will be removed before generating new documentation . Otherwise , if documentation exists in the specified ` output_dir ` the command will fail with a ` DocumentationAlreadyExists ` exception . - * modules * : One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () render . documentation ( project_configuration ( directory , config_file , modules ) , overwrite = overwrite ) print ( logo . ascii_art ) print ( \" Documentation successfully generated into `{}` ! \" . format ( os . path . abspath ( output_dir ))) in_browser def in_browser ( directory : str = '' , config_file : str = 'pyproject.toml' , port : int = None , host : str = None , modules : list = None ) -> None Opens your default webbrowser pointing to a locally started development webserver enabling you to browse documentation locally directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. port : The port to expose your documentation on (defaults to: 8000 ) host : The host to expose your documentation on (defaults to \"127.0.0.1\" ) modules : One or more modules to render reference documentation for View Source def in_browser ( directory : str = \"\" , config_file : str = \" pyproject.toml \" , port : int = None , host : str = None , modules : list = None , ) -> None : \"\"\" Opens your default webbrowser pointing to a locally started development webserver enabling you to browse documentation locally - * directory * : The root folder of your project . - * config_file * : The [ TOML ] ( https : // github . com / toml - lang / toml # toml ) formatted config file you wish to use . - * port * : The port to expose your documentation on ( defaults to : ` 8000 ` ) - * host * : The host to expose your documentation on ( defaults to ` \" 127.0.0.1 \" ` ) - * modules * : One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () server ( directory = directory , config_file = config_file , open_browser = True , modules = modules ) on_github_pages def on_github_pages ( directory : str = '' , config_file : str = 'pyproject.toml' , message : str = None , force : bool = False , ignore_version : bool = False , modules : list = None ) -> None Regenerates and deploys the documentation to GitHub pages. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. message : The commit message to use when uploading your documentation. force : Force the push to the repository. ignore_version : Ignore check that build is not being deployed with an old version. modules : One or more modules to render reference documentation for View Source def on_github_pages ( directory : str = \"\" , config_file : str = \" pyproject.toml \" , message : str = None , force : bool = False , ignore_version : bool = False , modules : list = None , ) -> None : \"\"\" Regenerates and deploys the documentation to GitHub pages. - * directory * : The root folder of your project . - * config_file * : The [ TOML ] ( https : // github . com / toml - lang / toml # toml ) formatted config file you wish to use . - * message * : The commit message to use when uploading your documentation . - * force * : Force the push to the repository . - * ignore_version * : Ignore check that build is not being deployed with an old version . - * modules * : One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () project_config = project_configuration ( directory , config_file , modules ) with render . documentation_in_temp_folder ( project_config ) : conf = render . _mkdocs_config ( project_config [ \" mkdocs \" ] ) conf . config_file_path = directory mkdocs . commands . gh_deploy . gh_deploy ( conf , message = message , force = force , ignore_version = ignore_version ) print ( logo . ascii_art ) print ( \" Documentation successfully generated and pushed! \" ) project_configuration def project_configuration ( directory : str = '' , config_file : str = 'pyproject.toml' , modules : list = None ) -> dict Returns the configuration associated with a project. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. modules : One or more modules to include in the configuration for reference rendering View Source def project_configuration ( directory : str = \"\" , config_file : str = \" pyproject.toml \" , modules : list = None ) -> dict : \"\"\" Returns the configuration associated with a project. - * directory * : The root folder of your project . - * config_file * : The [ TOML ] ( https : // github . com / toml - lang / toml # toml ) formatted config file you wish to use . - * modules * : One or more modules to include in the configuration for reference rendering \"\"\" overrides = {} if modules : overrides [ \" modules \" ] = modules directory = directory if directory else os . getcwd () return config . project ( directory = directory , config_file = config_file , ** overrides ) server def server ( directory : str = '' , config_file : str = 'pyproject.toml' , open_browser : bool = False , port : int = None , host : str = None , modules : list = None ) -> None Runs a development webserver enabling you to browse documentation locally. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. *open_browser\": If true a browser will be opened pointing at the documentation server port : The port to expose your documentation on (defaults to: 8000 ) host : The host to expose your documentation on (defaults to \"127.0.0.1\" ) modules : One or more modules to render reference documentation for View Source def server ( directory : str = \"\" , config_file : str = \" pyproject.toml \" , open_browser : bool = False , port : int = None , host : str = None , modules : list = None , ) -> None : \"\"\" Runs a development webserver enabling you to browse documentation locally. - * directory * : The root folder of your project . - * config_file * : The [ TOML ] ( https : // github . com / toml - lang / toml # toml ) formatted config file you wish to use . - * open_browser \" : If true a browser will be opened pointing at the documentation server - * port * : The port to expose your documentation on ( defaults to : ` 8000 ` ) - * host * : The host to expose your documentation on ( defaults to ` \" 127.0.0.1 \" ` ) - * modules * : One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () api = hug . API ( \" Doc Server \" ) project_config = project_configuration ( directory , config_file , modules ) with render . documentation_in_temp_folder ( project_config ) as doc_folder : @ hug . static ( \" / \" , api = api ) def my_static_dirs () : # pragma : no cover return ( doc_folder , ) @ hug . startup ( api = api ) def custom_startup ( * args , ** kwargs ) : # pragma : no cover print ( logo . ascii_art ) if open_browser : webbrowser . open_new ( \" http://{}:{} \" . format ( project_config [ \" host \" ], project_config [ \" port \" ] ) ) api . http . serve ( host = host or project_config [ \" host \" ], port = port or project_config [ \" port \" ], no_documentation = True , display_intro = False , )","title":"API"},{"location":"reference/portray/api/#module-portrayapi","text":"This module defines the programmatic API that can be used to interact with portray to generate and view documentation. If you want to extend portray or use it directly from within Python - this is the place to start. View Source \"\"\"This module defines the programmatic API that can be used to interact with `portray` to generate and view documentation. If you want to extend `portray` or use it directly from within Python - this is the place to start. \"\"\" import os import webbrowser from typing import Optional import hug import mkdocs.commands.gh_deploy from portray import config , logo , render def as_html ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , output_dir : str = \"site\" , overwrite : bool = False , modules : list = None , ) -> None : \"\"\"Produces HTML documentation for a Python project placing it into output_dir. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *output_dir*: The directory to place the generated HTML into. - *overwrite*: If set to `True` any existing documentation output will be removed before generating new documentation. Otherwise, if documentation exists in the specified `output_dir` the command will fail with a `DocumentationAlreadyExists` exception. - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () render . documentation ( project_configuration ( directory , config_file , modules ), overwrite = overwrite ) print ( logo . ascii_art ) print ( \"Documentation successfully generated into `{}` !\" . format ( os . path . abspath ( output_dir ))) def in_browser ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , port : int = None , host : str = None , modules : list = None , ) -> None : \"\"\"Opens your default webbrowser pointing to a locally started development webserver enabling you to browse documentation locally - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\"127.0.0.1\"`) - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () server ( directory = directory , config_file = config_file , open_browser = True , modules = modules ) def server ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , open_browser : bool = False , port : int = None , host : str = None , modules : list = None , ) -> None : \"\"\"Runs a development webserver enabling you to browse documentation locally. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *open_browser\": If true a browser will be opened pointing at the documentation server - *port*: The port to expose your documentation on (defaults to: `8000`) - *host*: The host to expose your documentation on (defaults to `\"127.0.0.1\"`) - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () api = hug . API ( \"Doc Server\" ) project_config = project_configuration ( directory , config_file , modules ) with render . documentation_in_temp_folder ( project_config ) as doc_folder : @hug.static ( \"/\" , api = api ) def my_static_dirs (): # pragma: no cover return ( doc_folder ,) @hug.startup ( api = api ) def custom_startup ( * args , ** kwargs ): # pragma: no cover print ( logo . ascii_art ) if open_browser : webbrowser . open_new ( \"http://{}:{}\" . format ( project_config [ \"host\" ], project_config [ \"port\" ]) ) api . http . serve ( host = host or project_config [ \"host\" ], port = port or project_config [ \"port\" ], no_documentation = True , display_intro = False , ) def project_configuration ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , modules : list = None ) -> dict : \"\"\"Returns the configuration associated with a project. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *modules*: One or more modules to include in the configuration for reference rendering \"\"\" overrides = {} if modules : overrides [ \"modules\" ] = modules directory = directory if directory else os . getcwd () return config . project ( directory = directory , config_file = config_file , ** overrides ) def on_github_pages ( directory : str = \"\" , config_file : str = \"pyproject.toml\" , message : str = None , force : bool = False , ignore_version : bool = False , modules : list = None , ) -> None : \"\"\"Regenerates and deploys the documentation to GitHub pages. - *directory*: The root folder of your project. - *config_file*: The [TOML](https://github.com/toml-lang/toml#toml) formatted config file you wish to use. - *message*: The commit message to use when uploading your documentation. - *force*: Force the push to the repository. - *ignore_version*: Ignore check that build is not being deployed with an old version. - *modules*: One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () project_config = project_configuration ( directory , config_file , modules ) with render . documentation_in_temp_folder ( project_config ): conf = render . _mkdocs_config ( project_config [ \"mkdocs\" ]) conf . config_file_path = directory mkdocs . commands . gh_deploy . gh_deploy ( conf , message = message , force = force , ignore_version = ignore_version ) print ( logo . ascii_art ) print ( \"Documentation successfully generated and pushed!\" )","title":"Module portray.api"},{"location":"reference/portray/api/#functions","text":"","title":"Functions"},{"location":"reference/portray/api/#as_html","text":"def as_html ( directory : str = '' , config_file : str = 'pyproject.toml' , output_dir : str = 'site' , overwrite : bool = False , modules : list = None ) -> None Produces HTML documentation for a Python project placing it into output_dir. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. output_dir : The directory to place the generated HTML into. overwrite : If set to True any existing documentation output will be removed before generating new documentation. Otherwise, if documentation exists in the specified output_dir the command will fail with a DocumentationAlreadyExists exception. modules : One or more modules to render reference documentation for View Source def as_html ( directory : str = \"\" , config_file : str = \" pyproject.toml \" , output_dir : str = \" site \" , overwrite : bool = False , modules : list = None , ) -> None : \"\"\" Produces HTML documentation for a Python project placing it into output_dir. - * directory * : The root folder of your project . - * config_file * : The [ TOML ] ( https : // github . com / toml - lang / toml # toml ) formatted config file you wish to use . - * output_dir * : The directory to place the generated HTML into . - * overwrite * : If set to ` True ` any existing documentation output will be removed before generating new documentation . Otherwise , if documentation exists in the specified ` output_dir ` the command will fail with a ` DocumentationAlreadyExists ` exception . - * modules * : One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () render . documentation ( project_configuration ( directory , config_file , modules ) , overwrite = overwrite ) print ( logo . ascii_art ) print ( \" Documentation successfully generated into `{}` ! \" . format ( os . path . abspath ( output_dir )))","title":"as_html"},{"location":"reference/portray/api/#in_browser","text":"def in_browser ( directory : str = '' , config_file : str = 'pyproject.toml' , port : int = None , host : str = None , modules : list = None ) -> None Opens your default webbrowser pointing to a locally started development webserver enabling you to browse documentation locally directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. port : The port to expose your documentation on (defaults to: 8000 ) host : The host to expose your documentation on (defaults to \"127.0.0.1\" ) modules : One or more modules to render reference documentation for View Source def in_browser ( directory : str = \"\" , config_file : str = \" pyproject.toml \" , port : int = None , host : str = None , modules : list = None , ) -> None : \"\"\" Opens your default webbrowser pointing to a locally started development webserver enabling you to browse documentation locally - * directory * : The root folder of your project . - * config_file * : The [ TOML ] ( https : // github . com / toml - lang / toml # toml ) formatted config file you wish to use . - * port * : The port to expose your documentation on ( defaults to : ` 8000 ` ) - * host * : The host to expose your documentation on ( defaults to ` \" 127.0.0.1 \" ` ) - * modules * : One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () server ( directory = directory , config_file = config_file , open_browser = True , modules = modules )","title":"in_browser"},{"location":"reference/portray/api/#on_github_pages","text":"def on_github_pages ( directory : str = '' , config_file : str = 'pyproject.toml' , message : str = None , force : bool = False , ignore_version : bool = False , modules : list = None ) -> None Regenerates and deploys the documentation to GitHub pages. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. message : The commit message to use when uploading your documentation. force : Force the push to the repository. ignore_version : Ignore check that build is not being deployed with an old version. modules : One or more modules to render reference documentation for View Source def on_github_pages ( directory : str = \"\" , config_file : str = \" pyproject.toml \" , message : str = None , force : bool = False , ignore_version : bool = False , modules : list = None , ) -> None : \"\"\" Regenerates and deploys the documentation to GitHub pages. - * directory * : The root folder of your project . - * config_file * : The [ TOML ] ( https : // github . com / toml - lang / toml # toml ) formatted config file you wish to use . - * message * : The commit message to use when uploading your documentation . - * force * : Force the push to the repository . - * ignore_version * : Ignore check that build is not being deployed with an old version . - * modules * : One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () project_config = project_configuration ( directory , config_file , modules ) with render . documentation_in_temp_folder ( project_config ) : conf = render . _mkdocs_config ( project_config [ \" mkdocs \" ] ) conf . config_file_path = directory mkdocs . commands . gh_deploy . gh_deploy ( conf , message = message , force = force , ignore_version = ignore_version ) print ( logo . ascii_art ) print ( \" Documentation successfully generated and pushed! \" )","title":"on_github_pages"},{"location":"reference/portray/api/#project_configuration","text":"def project_configuration ( directory : str = '' , config_file : str = 'pyproject.toml' , modules : list = None ) -> dict Returns the configuration associated with a project. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. modules : One or more modules to include in the configuration for reference rendering View Source def project_configuration ( directory : str = \"\" , config_file : str = \" pyproject.toml \" , modules : list = None ) -> dict : \"\"\" Returns the configuration associated with a project. - * directory * : The root folder of your project . - * config_file * : The [ TOML ] ( https : // github . com / toml - lang / toml # toml ) formatted config file you wish to use . - * modules * : One or more modules to include in the configuration for reference rendering \"\"\" overrides = {} if modules : overrides [ \" modules \" ] = modules directory = directory if directory else os . getcwd () return config . project ( directory = directory , config_file = config_file , ** overrides )","title":"project_configuration"},{"location":"reference/portray/api/#server","text":"def server ( directory : str = '' , config_file : str = 'pyproject.toml' , open_browser : bool = False , port : int = None , host : str = None , modules : list = None ) -> None Runs a development webserver enabling you to browse documentation locally. directory : The root folder of your project. config_file : The TOML formatted config file you wish to use. *open_browser\": If true a browser will be opened pointing at the documentation server port : The port to expose your documentation on (defaults to: 8000 ) host : The host to expose your documentation on (defaults to \"127.0.0.1\" ) modules : One or more modules to render reference documentation for View Source def server ( directory : str = \"\" , config_file : str = \" pyproject.toml \" , open_browser : bool = False , port : int = None , host : str = None , modules : list = None , ) -> None : \"\"\" Runs a development webserver enabling you to browse documentation locally. - * directory * : The root folder of your project . - * config_file * : The [ TOML ] ( https : // github . com / toml - lang / toml # toml ) formatted config file you wish to use . - * open_browser \" : If true a browser will be opened pointing at the documentation server - * port * : The port to expose your documentation on ( defaults to : ` 8000 ` ) - * host * : The host to expose your documentation on ( defaults to ` \" 127.0.0.1 \" ` ) - * modules * : One or more modules to render reference documentation for \"\"\" directory = directory if directory else os . getcwd () api = hug . API ( \" Doc Server \" ) project_config = project_configuration ( directory , config_file , modules ) with render . documentation_in_temp_folder ( project_config ) as doc_folder : @ hug . static ( \" / \" , api = api ) def my_static_dirs () : # pragma : no cover return ( doc_folder , ) @ hug . startup ( api = api ) def custom_startup ( * args , ** kwargs ) : # pragma : no cover print ( logo . ascii_art ) if open_browser : webbrowser . open_new ( \" http://{}:{} \" . format ( project_config [ \" host \" ], project_config [ \" port \" ] ) ) api . http . serve ( host = host or project_config [ \" host \" ], port = port or project_config [ \" port \" ], no_documentation = True , display_intro = False , )","title":"server"},{"location":"reference/portray/cli/","text":"Module portray.cli This module defines CLI interaction when using portray . This is powered by hug which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the API module portray as_html : Renders the project as HTML into the site or other specified output directory portray in_browser : Runs a server with the rendered documentation pointing a browser to it portray server : Starts a local development server (by default at localhost:8000) portray project_configuration : Returns back the project configuration as determined by portray View Source \"\"\"This module defines CLI interaction when using `portray`. This is powered by [hug](https://github.com/hugapi/hug) which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the [API module](/reference/portray/api) - `portray as_html`: Renders the project as HTML into the `site` or other specified output directory - `portray in_browser`: Runs a server with the rendered documentation pointing a browser to it - `portray server`: Starts a local development server (by default at localhost:8000) - `portray project_configuration`: Returns back the project configuration as determined by` portray` \"\"\" from pprint import pprint import hug from portray import api , logo cli = hug . cli ( api = hug . API ( __name__ , doc = logo . ascii_art )) cli ( api . as_html ) cli . output ( pprint )( api . project_configuration ) cli ( api . server ) cli ( api . in_browser ) cli ( api . on_github_pages ) Variables cli","title":"CLI"},{"location":"reference/portray/cli/#module-portraycli","text":"This module defines CLI interaction when using portray . This is powered by hug which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the API module portray as_html : Renders the project as HTML into the site or other specified output directory portray in_browser : Runs a server with the rendered documentation pointing a browser to it portray server : Starts a local development server (by default at localhost:8000) portray project_configuration : Returns back the project configuration as determined by portray View Source \"\"\"This module defines CLI interaction when using `portray`. This is powered by [hug](https://github.com/hugapi/hug) which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the [API module](/reference/portray/api) - `portray as_html`: Renders the project as HTML into the `site` or other specified output directory - `portray in_browser`: Runs a server with the rendered documentation pointing a browser to it - `portray server`: Starts a local development server (by default at localhost:8000) - `portray project_configuration`: Returns back the project configuration as determined by` portray` \"\"\" from pprint import pprint import hug from portray import api , logo cli = hug . cli ( api = hug . API ( __name__ , doc = logo . ascii_art )) cli ( api . as_html ) cli . output ( pprint )( api . project_configuration ) cli ( api . server ) cli ( api . in_browser ) cli ( api . on_github_pages )","title":"Module portray.cli"},{"location":"reference/portray/cli/#variables","text":"cli","title":"Variables"},{"location":"reference/portray/config/","text":"Module portray.config Defines the configuration defaults and load functions used by portray View Source \"\"\"Defines the configuration defaults and load functions used by `portray`\"\"\" import ast import os import warnings from typing import Any , Dict , List , Union , cast from urllib import parse import mkdocs.config as _mkdocs_config import mkdocs.exceptions as _mkdocs_exceptions from git import Repo from toml import load as toml_load import _ast from portray.exceptions import NoProjectFound PORTRAY_DEFAULTS = { \"docs_dir\" : \"docs\" , \"output_dir\" : \"site\" , \"port\" : 8000 , \"host\" : \"127.0.0.1\" , \"labels\" : { \"Cli\" : \"CLI\" , \"Api\" : \"API\" , \"Http\" : \"HTTP\" , \"Pypi\" : \"PyPI\" }, } MKDOCS_DEFAULTS = { \"site_name\" : os . path . basename ( os . getcwd ()), \"config_file_path\" : os . getcwd (), \"theme\" : { \"name\" : \"material\" , \"palette\" : { \"primary\" : \"green\" , \"accent\" : \"lightgreen\" }, \"custom_dir\" : os . path . join ( os . path . dirname ( __file__ ), \"mkdocs_templates\" ), }, \"markdown_extensions\" : [ \"admonition\" , \"codehilite\" , \"extra\" , \"pymdownx.details\" , \"pymdownx.highlight\" , ], } # type: Dict[str, Any] PDOCS_DEFAULTS = { \"overwrite\" : True , \"exclude_source\" : False , \"template_dir\" : os . path . join ( os . path . dirname ( __file__ ), \"pdocs_templates\" ), } # type: Dict[str, Union[str, str, bool, None, Dict, List]] def project ( directory : str , config_file : str , ** overrides ) -> dict : \"\"\"Returns back the complete configuration - including all sub configuration components defined below that `portray` was able to determine for the project \"\"\" if not ( os . path . isfile ( os . path . join ( directory , config_file )) or os . path . isfile ( os . path . join ( directory , \"setup.py\" )) or \"modules\" in overrides ): raise NoProjectFound ( directory ) project_config = { ** PORTRAY_DEFAULTS , \"directory\" : directory } # type: Dict[str, Any] if os . path . isfile ( os . path . join ( directory , \"setup.py\" )): project_config . update ( setup_py ( os . path . join ( directory , \"setup.py\" ))) project_config . update ( toml ( os . path . join ( directory , config_file ), ** overrides )) project_config . setdefault ( \"modules\" , [ os . path . basename ( os . getcwd ())]) project_config . setdefault ( \"pdocs\" , {}) . setdefault ( \"modules\" , project_config [ \"modules\" ]) project_config [ \"mkdocs\" ] = mkdocs ( directory , ** project_config . get ( \"mkdocs\" , {})) if \"pdoc3\" in project_config : warnings . warn ( \"pdoc3 config usage is deprecated in favor of pdocs. \" \"pdoc3 section will be ignored. \" , DeprecationWarning ) project_config [ \"pdocs\" ] = pdocs ( directory , ** project_config . get ( \"pdocs\" , {}) ) return project_config def setup_py ( location : str ) -> dict : \"\"\"Returns back any configuration info we are able to determine from a setup.py file\"\"\" setup_config = {} try : with open ( location ) as setup_py_file : for node in ast . walk ( ast . parse ( setup_py_file . read ())): if ( type ( node ) == _ast . Call and type ( getattr ( node , \"func\" , None )) == _ast . Name and node . func . id == \"setup\" # type: ignore ): for keyword in node . keywords : # type: ignore if keyword . arg == \"packages\" : setup_config [ \"modules\" ] = ast . literal_eval ( keyword . value ) break break except Exception as error : warnings . warn ( f \"Error ({error}) occurred trying to parse setup.py file: {location}\" ) return setup_config def toml ( location : str , ** overrides ) -> dict : \"\"\"Returns back the configuration found within the projects [TOML](https://github.com/toml-lang/toml#toml) config (if there is one). Generally this is a `pyproject.toml` file at the root of the project with a `[tool.portray]` section defined. \"\"\" try : toml_config = toml_load ( location ) tools = toml_config . get ( \"tool\" , {}) config = tools . get ( \"portray\" , {}) config . update ( overrides ) config [ \"file\" ] = location if \"modules\" not in config : if \"poetry\" in tools and \"name\" in tools [ \"poetry\" ]: config [ \"modules\" ] = [ tools [ \"poetry\" ][ \"name\" ]] elif ( \"flit\" in tools and \"metadata\" in tools [ \"flit\" ] and \"module\" in tools [ \"flit\" ][ \"metadata\" ] ): config [ \"modules\" ] = [ tools [ \"flit\" ][ \"metadata\" ][ \"module\" ]] return config except Exception : warnings . warn ( f \"No {location} config file found\" ) return {} def repository ( directory : str ) -> dict : \"\"\"Returns back any information that can be determined by introspecting the projects git repo (if there is one). \"\"\" config = {} try : repo_url = Repo ( directory ) . remotes . origin . url if \"http\" in repo_url : config [ \"repo_url\" ] = repo_url config [ \"repo_name\" ] = parse . urlsplit ( repo_url ) . path . rstrip ( \".git\" ) . lstrip ( \"/\" ) except Exception : config = {} if not config : warnings . warn ( \"Unable to identify `repo_name` and `repo_url` automatically\" ) return config def mkdocs ( directory : str , ** overrides ) -> dict : \"\"\"Returns back the configuration that will be used when running mkdocs\"\"\" mkdocs_config = { ** MKDOCS_DEFAULTS , ** repository ( directory ), ** overrides , } # type: Dict[str, Any] theme = mkdocs_config [ \"theme\" ] if theme [ \"name\" ] . lower () == \"material\" and \"custom_dir\" not in theme : theme [ \"custom_dir\" ] = MKDOCS_DEFAULTS [ \"theme\" ][ \"custom_dir\" ] return mkdocs_config def pdocs ( directory : str , ** overrides ) -> dict : \"\"\"Returns back the configuration that will be used when running pdocs\"\"\" defaults = { ** PDOCS_DEFAULTS } defaults . update ( overrides ) return defaults Variables MKDOCS_DEFAULTS PDOCS_DEFAULTS PORTRAY_DEFAULTS Functions mkdocs def mkdocs ( directory : str , ** overrides ) -> dict Returns back the configuration that will be used when running mkdocs View Source def mkdocs ( directory : str , ** overrides ) -> dict : \"\"\" Returns back the configuration that will be used when running mkdocs \"\"\" mkdocs_config = { ** MKDOCS_DEFAULTS , ** repository ( directory ) , ** overrides , } # type : Dict [ str , Any ] theme = mkdocs_config [ \" theme \" ] if theme [ \" name \" ]. lower () == \" material \" and \" custom_dir \" not in theme : theme [ \" custom_dir \" ] = MKDOCS_DEFAULTS [ \" theme \" ][ \" custom_dir \" ] return mkdocs_config pdocs def pdocs ( directory : str , ** overrides ) -> dict Returns back the configuration that will be used when running pdocs View Source def pdocs ( directory : str , ** overrides ) -> dict : \"\"\" Returns back the configuration that will be used when running pdocs \"\"\" defaults = { ** PDOCS_DEFAULTS } defaults . update ( overrides ) return defaults project def project ( directory : str , config_file : str , ** overrides ) -> dict Returns back the complete configuration - including all sub configuration components defined below that portray was able to determine for the project View Source def project ( directory : str , config_file : str , ** overrides ) -> dict : \"\"\" Returns back the complete configuration - including all sub configuration components defined below that ` portray ` was able to determine for the project \"\"\" if not ( os . path . isfile ( os . path . join ( directory , config_file )) or os . path . isfile ( os . path . join ( directory , \" setup.py \" )) or \" modules \" in overrides ) : raise NoProjectFound ( directory ) project_config = { ** PORTRAY_DEFAULTS , \" directory \" : directory } # type : Dict [ str , Any ] if os . path . isfile ( os . path . join ( directory , \" setup.py \" )) : project_config . update ( setup_py ( os . path . join ( directory , \" setup.py \" ))) project_config . update ( toml ( os . path . join ( directory , config_file ) , ** overrides )) project_config . setdefault ( \" modules \" , [ os . path . basename ( os . getcwd ()) ] ) project_config . setdefault ( \" pdocs \" , {} ) . setdefault ( \" modules \" , project_config [ \" modules \" ] ) project_config [ \" mkdocs \" ] = mkdocs ( directory , ** project_config . get ( \" mkdocs \" , {} )) if \" pdoc3 \" in project_config : warnings . warn ( \" pdoc3 config usage is deprecated in favor of pdocs. \" \" pdoc3 section will be ignored. \" , DeprecationWarning ) project_config [ \" pdocs \" ] = pdocs ( directory , ** project_config . get ( \" pdocs \" , {} ) ) return project_config repository def repository ( directory : str ) -> dict Returns back any information that can be determined by introspecting the projects git repo (if there is one). View Source def repository ( directory : str ) -> dict : \"\"\" Returns back any information that can be determined by introspecting the projects git repo ( if there is one ) . \"\"\" config = {} try : repo_url = Repo ( directory ) . remotes . origin . url if \" http \" in repo_url : config [ \" repo_url \" ] = repo_url config [ \" repo_name \" ] = parse . urlsplit ( repo_url ) . path . rstrip ( \" .git \" ) . lstrip ( \" / \" ) except Exception : config = {} if not config : warnings . warn ( \" Unable to identify `repo_name` and `repo_url` automatically \" ) return config setup_py def setup_py ( location : str ) -> dict Returns back any configuration info we are able to determine from a setup.py file View Source def setup_py ( location : str ) -> dict : \"\"\" Returns back any configuration info we are able to determine from a setup.py file \"\"\" setup_config = {} try : with open ( location ) as setup_py_file : for node in ast . walk ( ast . parse ( setup_py_file . read ())) : if ( type ( node ) == _ast . Call and type ( getattr ( node , \" func \" , None )) == _ast . Name and node . func . id == \" setup \" # type : ignore ) : for keyword in node . keywords : # type : ignore if keyword . arg == \" packages \" : setup_config [ \" modules \" ] = ast . literal_eval ( keyword . value ) break break except Exception as error : warnings . warn ( f \" Error ({error}) occurred trying to parse setup.py file: {location} \" ) return setup_config toml def toml ( location : str , ** overrides ) -> dict Returns back the configuration found within the projects TOML config (if there is one). Generally this is a pyproject.toml file at the root of the project with a [tool.portray] section defined. View Source def toml ( location : str , ** overrides ) -> dict : \"\"\" Returns back the configuration found within the projects [ TOML ] ( https : // github . com / toml - lang / toml # toml ) config ( if there is one ) . Generally this is a ` pyproject . toml ` file at the root of the project with a `[ tool . portray ]` section defined . \"\"\" try : toml_config = toml_load ( location ) tools = toml_config . get ( \" tool \" , {} ) config = tools . get ( \" portray \" , {} ) config . update ( overrides ) config [ \" file \" ] = location if \" modules \" not in config : if \" poetry \" in tools and \" name \" in tools [ \" poetry \" ]: config [ \" modules \" ] = [ tools [ \" poetry \" ][ \" name \" ]] elif ( \" flit \" in tools and \" metadata \" in tools [ \" flit \" ] and \" module \" in tools [ \" flit \" ][ \" metadata \" ] ) : config [ \" modules \" ] = [ tools [ \" flit \" ][ \" metadata \" ][ \" module \" ]] return config except Exception : warnings . warn ( f \" No {location} config file found \" ) return {}","title":"Config"},{"location":"reference/portray/config/#module-portrayconfig","text":"Defines the configuration defaults and load functions used by portray View Source \"\"\"Defines the configuration defaults and load functions used by `portray`\"\"\" import ast import os import warnings from typing import Any , Dict , List , Union , cast from urllib import parse import mkdocs.config as _mkdocs_config import mkdocs.exceptions as _mkdocs_exceptions from git import Repo from toml import load as toml_load import _ast from portray.exceptions import NoProjectFound PORTRAY_DEFAULTS = { \"docs_dir\" : \"docs\" , \"output_dir\" : \"site\" , \"port\" : 8000 , \"host\" : \"127.0.0.1\" , \"labels\" : { \"Cli\" : \"CLI\" , \"Api\" : \"API\" , \"Http\" : \"HTTP\" , \"Pypi\" : \"PyPI\" }, } MKDOCS_DEFAULTS = { \"site_name\" : os . path . basename ( os . getcwd ()), \"config_file_path\" : os . getcwd (), \"theme\" : { \"name\" : \"material\" , \"palette\" : { \"primary\" : \"green\" , \"accent\" : \"lightgreen\" }, \"custom_dir\" : os . path . join ( os . path . dirname ( __file__ ), \"mkdocs_templates\" ), }, \"markdown_extensions\" : [ \"admonition\" , \"codehilite\" , \"extra\" , \"pymdownx.details\" , \"pymdownx.highlight\" , ], } # type: Dict[str, Any] PDOCS_DEFAULTS = { \"overwrite\" : True , \"exclude_source\" : False , \"template_dir\" : os . path . join ( os . path . dirname ( __file__ ), \"pdocs_templates\" ), } # type: Dict[str, Union[str, str, bool, None, Dict, List]] def project ( directory : str , config_file : str , ** overrides ) -> dict : \"\"\"Returns back the complete configuration - including all sub configuration components defined below that `portray` was able to determine for the project \"\"\" if not ( os . path . isfile ( os . path . join ( directory , config_file )) or os . path . isfile ( os . path . join ( directory , \"setup.py\" )) or \"modules\" in overrides ): raise NoProjectFound ( directory ) project_config = { ** PORTRAY_DEFAULTS , \"directory\" : directory } # type: Dict[str, Any] if os . path . isfile ( os . path . join ( directory , \"setup.py\" )): project_config . update ( setup_py ( os . path . join ( directory , \"setup.py\" ))) project_config . update ( toml ( os . path . join ( directory , config_file ), ** overrides )) project_config . setdefault ( \"modules\" , [ os . path . basename ( os . getcwd ())]) project_config . setdefault ( \"pdocs\" , {}) . setdefault ( \"modules\" , project_config [ \"modules\" ]) project_config [ \"mkdocs\" ] = mkdocs ( directory , ** project_config . get ( \"mkdocs\" , {})) if \"pdoc3\" in project_config : warnings . warn ( \"pdoc3 config usage is deprecated in favor of pdocs. \" \"pdoc3 section will be ignored. \" , DeprecationWarning ) project_config [ \"pdocs\" ] = pdocs ( directory , ** project_config . get ( \"pdocs\" , {}) ) return project_config def setup_py ( location : str ) -> dict : \"\"\"Returns back any configuration info we are able to determine from a setup.py file\"\"\" setup_config = {} try : with open ( location ) as setup_py_file : for node in ast . walk ( ast . parse ( setup_py_file . read ())): if ( type ( node ) == _ast . Call and type ( getattr ( node , \"func\" , None )) == _ast . Name and node . func . id == \"setup\" # type: ignore ): for keyword in node . keywords : # type: ignore if keyword . arg == \"packages\" : setup_config [ \"modules\" ] = ast . literal_eval ( keyword . value ) break break except Exception as error : warnings . warn ( f \"Error ({error}) occurred trying to parse setup.py file: {location}\" ) return setup_config def toml ( location : str , ** overrides ) -> dict : \"\"\"Returns back the configuration found within the projects [TOML](https://github.com/toml-lang/toml#toml) config (if there is one). Generally this is a `pyproject.toml` file at the root of the project with a `[tool.portray]` section defined. \"\"\" try : toml_config = toml_load ( location ) tools = toml_config . get ( \"tool\" , {}) config = tools . get ( \"portray\" , {}) config . update ( overrides ) config [ \"file\" ] = location if \"modules\" not in config : if \"poetry\" in tools and \"name\" in tools [ \"poetry\" ]: config [ \"modules\" ] = [ tools [ \"poetry\" ][ \"name\" ]] elif ( \"flit\" in tools and \"metadata\" in tools [ \"flit\" ] and \"module\" in tools [ \"flit\" ][ \"metadata\" ] ): config [ \"modules\" ] = [ tools [ \"flit\" ][ \"metadata\" ][ \"module\" ]] return config except Exception : warnings . warn ( f \"No {location} config file found\" ) return {} def repository ( directory : str ) -> dict : \"\"\"Returns back any information that can be determined by introspecting the projects git repo (if there is one). \"\"\" config = {} try : repo_url = Repo ( directory ) . remotes . origin . url if \"http\" in repo_url : config [ \"repo_url\" ] = repo_url config [ \"repo_name\" ] = parse . urlsplit ( repo_url ) . path . rstrip ( \".git\" ) . lstrip ( \"/\" ) except Exception : config = {} if not config : warnings . warn ( \"Unable to identify `repo_name` and `repo_url` automatically\" ) return config def mkdocs ( directory : str , ** overrides ) -> dict : \"\"\"Returns back the configuration that will be used when running mkdocs\"\"\" mkdocs_config = { ** MKDOCS_DEFAULTS , ** repository ( directory ), ** overrides , } # type: Dict[str, Any] theme = mkdocs_config [ \"theme\" ] if theme [ \"name\" ] . lower () == \"material\" and \"custom_dir\" not in theme : theme [ \"custom_dir\" ] = MKDOCS_DEFAULTS [ \"theme\" ][ \"custom_dir\" ] return mkdocs_config def pdocs ( directory : str , ** overrides ) -> dict : \"\"\"Returns back the configuration that will be used when running pdocs\"\"\" defaults = { ** PDOCS_DEFAULTS } defaults . update ( overrides ) return defaults","title":"Module portray.config"},{"location":"reference/portray/config/#variables","text":"MKDOCS_DEFAULTS PDOCS_DEFAULTS PORTRAY_DEFAULTS","title":"Variables"},{"location":"reference/portray/config/#functions","text":"","title":"Functions"},{"location":"reference/portray/config/#mkdocs","text":"def mkdocs ( directory : str , ** overrides ) -> dict Returns back the configuration that will be used when running mkdocs View Source def mkdocs ( directory : str , ** overrides ) -> dict : \"\"\" Returns back the configuration that will be used when running mkdocs \"\"\" mkdocs_config = { ** MKDOCS_DEFAULTS , ** repository ( directory ) , ** overrides , } # type : Dict [ str , Any ] theme = mkdocs_config [ \" theme \" ] if theme [ \" name \" ]. lower () == \" material \" and \" custom_dir \" not in theme : theme [ \" custom_dir \" ] = MKDOCS_DEFAULTS [ \" theme \" ][ \" custom_dir \" ] return mkdocs_config","title":"mkdocs"},{"location":"reference/portray/config/#pdocs","text":"def pdocs ( directory : str , ** overrides ) -> dict Returns back the configuration that will be used when running pdocs View Source def pdocs ( directory : str , ** overrides ) -> dict : \"\"\" Returns back the configuration that will be used when running pdocs \"\"\" defaults = { ** PDOCS_DEFAULTS } defaults . update ( overrides ) return defaults","title":"pdocs"},{"location":"reference/portray/config/#project","text":"def project ( directory : str , config_file : str , ** overrides ) -> dict Returns back the complete configuration - including all sub configuration components defined below that portray was able to determine for the project View Source def project ( directory : str , config_file : str , ** overrides ) -> dict : \"\"\" Returns back the complete configuration - including all sub configuration components defined below that ` portray ` was able to determine for the project \"\"\" if not ( os . path . isfile ( os . path . join ( directory , config_file )) or os . path . isfile ( os . path . join ( directory , \" setup.py \" )) or \" modules \" in overrides ) : raise NoProjectFound ( directory ) project_config = { ** PORTRAY_DEFAULTS , \" directory \" : directory } # type : Dict [ str , Any ] if os . path . isfile ( os . path . join ( directory , \" setup.py \" )) : project_config . update ( setup_py ( os . path . join ( directory , \" setup.py \" ))) project_config . update ( toml ( os . path . join ( directory , config_file ) , ** overrides )) project_config . setdefault ( \" modules \" , [ os . path . basename ( os . getcwd ()) ] ) project_config . setdefault ( \" pdocs \" , {} ) . setdefault ( \" modules \" , project_config [ \" modules \" ] ) project_config [ \" mkdocs \" ] = mkdocs ( directory , ** project_config . get ( \" mkdocs \" , {} )) if \" pdoc3 \" in project_config : warnings . warn ( \" pdoc3 config usage is deprecated in favor of pdocs. \" \" pdoc3 section will be ignored. \" , DeprecationWarning ) project_config [ \" pdocs \" ] = pdocs ( directory , ** project_config . get ( \" pdocs \" , {} ) ) return project_config","title":"project"},{"location":"reference/portray/config/#repository","text":"def repository ( directory : str ) -> dict Returns back any information that can be determined by introspecting the projects git repo (if there is one). View Source def repository ( directory : str ) -> dict : \"\"\" Returns back any information that can be determined by introspecting the projects git repo ( if there is one ) . \"\"\" config = {} try : repo_url = Repo ( directory ) . remotes . origin . url if \" http \" in repo_url : config [ \" repo_url \" ] = repo_url config [ \" repo_name \" ] = parse . urlsplit ( repo_url ) . path . rstrip ( \" .git \" ) . lstrip ( \" / \" ) except Exception : config = {} if not config : warnings . warn ( \" Unable to identify `repo_name` and `repo_url` automatically \" ) return config","title":"repository"},{"location":"reference/portray/config/#setup_py","text":"def setup_py ( location : str ) -> dict Returns back any configuration info we are able to determine from a setup.py file View Source def setup_py ( location : str ) -> dict : \"\"\" Returns back any configuration info we are able to determine from a setup.py file \"\"\" setup_config = {} try : with open ( location ) as setup_py_file : for node in ast . walk ( ast . parse ( setup_py_file . read ())) : if ( type ( node ) == _ast . Call and type ( getattr ( node , \" func \" , None )) == _ast . Name and node . func . id == \" setup \" # type : ignore ) : for keyword in node . keywords : # type : ignore if keyword . arg == \" packages \" : setup_config [ \" modules \" ] = ast . literal_eval ( keyword . value ) break break except Exception as error : warnings . warn ( f \" Error ({error}) occurred trying to parse setup.py file: {location} \" ) return setup_config","title":"setup_py"},{"location":"reference/portray/config/#toml","text":"def toml ( location : str , ** overrides ) -> dict Returns back the configuration found within the projects TOML config (if there is one). Generally this is a pyproject.toml file at the root of the project with a [tool.portray] section defined. View Source def toml ( location : str , ** overrides ) -> dict : \"\"\" Returns back the configuration found within the projects [ TOML ] ( https : // github . com / toml - lang / toml # toml ) config ( if there is one ) . Generally this is a ` pyproject . toml ` file at the root of the project with a `[ tool . portray ]` section defined . \"\"\" try : toml_config = toml_load ( location ) tools = toml_config . get ( \" tool \" , {} ) config = tools . get ( \" portray \" , {} ) config . update ( overrides ) config [ \" file \" ] = location if \" modules \" not in config : if \" poetry \" in tools and \" name \" in tools [ \" poetry \" ]: config [ \" modules \" ] = [ tools [ \" poetry \" ][ \" name \" ]] elif ( \" flit \" in tools and \" metadata \" in tools [ \" flit \" ] and \" module \" in tools [ \" flit \" ][ \" metadata \" ] ) : config [ \" modules \" ] = [ tools [ \" flit \" ][ \" metadata \" ][ \" module \" ]] return config except Exception : warnings . warn ( f \" No {location} config file found \" ) return {}","title":"toml"},{"location":"reference/portray/exceptions/","text":"Module portray.exceptions All portray specific exception classes should be defined here View Source \"\"\" All portray specific exception classes should be defined here \"\"\" class PortrayError ( Exception ) : \"\"\" Base class for all exceptions returned from portray \"\"\" pass class NoProjectFound ( PortrayError ) : \"\"\" Thrown when portray is ran in a directory with no Python project \"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \" No Python project found in the given directory: '{directory}' \" + \" See: https://timothycrosley.github.io/portray/TROUBLESHOOTING/#noprojectfound \" , ) self . directory = directory def yolo ( self ) : \"\"\" Why?!?! \"\"\" return True class DocumentationAlreadyExists ( PortrayError ) : \"\"\" Thrown when portray has been told to output documentation where it already exists \"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \" Documentation already exists in '{directory}'. Use --overwrite to ignore \" ) self . directory = directory Classes DocumentationAlreadyExists class DocumentationAlreadyExists ( directory : str ) Thrown when portray has been told to output documentation where it already exists View Source class DocumentationAlreadyExists ( PortrayError ): \"\"\"Thrown when portray has been told to output documentation where it already exists\"\"\" def __init__ ( self , directory: str ): super (). __init__ ( self , f \"Documentation already exists in '{directory}'. Use --overwrite to ignore\" ) self . directory = directory Ancestors (in MRO) portray.exceptions.PortrayError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. NoProjectFound class NoProjectFound ( directory : str ) Thrown when portray is ran in a directory with no Python project View Source class NoProjectFound ( PortrayError ) : \"\"\" Thrown when portray is ran in a directory with no Python project \"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \" No Python project found in the given directory: '{directory}' \" + \" See: https://timothycrosley.github.io/portray/TROUBLESHOOTING/#noprojectfound \" , ) self . directory = directory def yolo ( self ) : \"\"\" Why?!?! \"\"\" return True Ancestors (in MRO) portray.exceptions.PortrayError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. yolo def yolo ( self ) Why?!?! View Source def yolo ( self ) : \"\"\" Why?!?! \"\"\" return True PortrayError class PortrayError ( / , * args , ** kwargs ) Base class for all exceptions returned from portray View Source class PortrayError ( Exception ) : \"\"\" Base class for all exceptions returned from portray \"\"\" pass Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants portray.exceptions.NoProjectFound portray.exceptions.DocumentationAlreadyExists Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exceptions"},{"location":"reference/portray/exceptions/#module-portrayexceptions","text":"All portray specific exception classes should be defined here View Source \"\"\" All portray specific exception classes should be defined here \"\"\" class PortrayError ( Exception ) : \"\"\" Base class for all exceptions returned from portray \"\"\" pass class NoProjectFound ( PortrayError ) : \"\"\" Thrown when portray is ran in a directory with no Python project \"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \" No Python project found in the given directory: '{directory}' \" + \" See: https://timothycrosley.github.io/portray/TROUBLESHOOTING/#noprojectfound \" , ) self . directory = directory def yolo ( self ) : \"\"\" Why?!?! \"\"\" return True class DocumentationAlreadyExists ( PortrayError ) : \"\"\" Thrown when portray has been told to output documentation where it already exists \"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \" Documentation already exists in '{directory}'. Use --overwrite to ignore \" ) self . directory = directory","title":"Module portray.exceptions"},{"location":"reference/portray/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/portray/exceptions/#documentationalreadyexists","text":"class DocumentationAlreadyExists ( directory : str ) Thrown when portray has been told to output documentation where it already exists View Source class DocumentationAlreadyExists ( PortrayError ): \"\"\"Thrown when portray has been told to output documentation where it already exists\"\"\" def __init__ ( self , directory: str ): super (). __init__ ( self , f \"Documentation already exists in '{directory}'. Use --overwrite to ignore\" ) self . directory = directory","title":"DocumentationAlreadyExists"},{"location":"reference/portray/exceptions/#ancestors-in-mro","text":"portray.exceptions.PortrayError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/portray/exceptions/#class-variables","text":"args","title":"Class variables"},{"location":"reference/portray/exceptions/#methods","text":"","title":"Methods"},{"location":"reference/portray/exceptions/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/portray/exceptions/#noprojectfound","text":"class NoProjectFound ( directory : str ) Thrown when portray is ran in a directory with no Python project View Source class NoProjectFound ( PortrayError ) : \"\"\" Thrown when portray is ran in a directory with no Python project \"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \" No Python project found in the given directory: '{directory}' \" + \" See: https://timothycrosley.github.io/portray/TROUBLESHOOTING/#noprojectfound \" , ) self . directory = directory def yolo ( self ) : \"\"\" Why?!?! \"\"\" return True","title":"NoProjectFound"},{"location":"reference/portray/exceptions/#ancestors-in-mro_1","text":"portray.exceptions.PortrayError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/portray/exceptions/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/portray/exceptions/#methods_1","text":"","title":"Methods"},{"location":"reference/portray/exceptions/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/portray/exceptions/#yolo","text":"def yolo ( self ) Why?!?! View Source def yolo ( self ) : \"\"\" Why?!?! \"\"\" return True","title":"yolo"},{"location":"reference/portray/exceptions/#portrayerror","text":"class PortrayError ( / , * args , ** kwargs ) Base class for all exceptions returned from portray View Source class PortrayError ( Exception ) : \"\"\" Base class for all exceptions returned from portray \"\"\" pass","title":"PortrayError"},{"location":"reference/portray/exceptions/#ancestors-in-mro_2","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/portray/exceptions/#descendants","text":"portray.exceptions.NoProjectFound portray.exceptions.DocumentationAlreadyExists","title":"Descendants"},{"location":"reference/portray/exceptions/#class-variables_2","text":"args","title":"Class variables"},{"location":"reference/portray/exceptions/#methods_2","text":"","title":"Methods"},{"location":"reference/portray/exceptions/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/portray/logo/","text":"Module portray.logo __ / \\ \\ __ _____ ___ _ __ \\ \\ , _ \\ _ __ __ __ __ / \\ '__`\\ / __`\\/\\`' __ \\ \\ \\ / / \\ `'__\\/'__` \\ / \\ \\ / \\ \\ \\ \\ \\ L \\ \\ / \\ \\ L \\ \\ \\ \\ / \\ \\ \\ _ \\ \\ \\ // \\ \\ L \\ . \\ _ \\ \\ \\ _ \\ \\ \\ \\ , __ / \\ \\ ____ / \\ \\ _ \\ \\ \\ __ \\\\ \\ _ \\\\ \\ __ /. \\ _ \\\\ / ` ____ \\ \\ \\ \\ / \\ / ___ / \\ / _ / \\ / __ / \\ / _ / \\ / __ / \\ / _ / ` / ___ /> \\ \\ \\ _ \\ / \\ ___ / \\ / _ / \\ / __ / Your Project with Great Documentation . Version : 1.2 . 0 Copyright Timothy Edmund Crosley 2019 MIT License View Source from portray._version import __version__ ascii_art = rf \"\"\" __ /\\ \\__ _____ ___ _ __\\ \\ ,_\\ _ __ __ __ __ /\\ '__`\\ / __`\\/\\`'__\\ \\ \\/ /\\`'__\\/'__`\\ /\\ \\/\\ \\ \\ \\ \\L\\ \\/\\ \\L\\ \\ \\ \\/ \\ \\ \\_\\ \\ \\//\\ \\L\\.\\_\\ \\ \\_\\ \\ \\ \\ ,__/\\ \\____/\\ \\_\\ \\ \\__ \\\\ \\_ \\\\ \\__/.\\_ \\\\ /`____ \\ \\ \\ \\/ \\/___/ \\/_/ \\/__/ \\/_/ \\/__/\\/_/ `/___/> \\ \\ \\_\\ /\\___/ \\/_/ \\/__/ Your Project with Great Documentation. Version: {__version__} Copyright Timothy Edmund Crosley 2019 MIT License \"\"\" __doc__ = f \"\"\" ```python {ascii_art} ``` \"\"\" Variables ascii_art","title":"Logo"},{"location":"reference/portray/logo/#module-portraylogo","text":"__ / \\ \\ __ _____ ___ _ __ \\ \\ , _ \\ _ __ __ __ __ / \\ '__`\\ / __`\\/\\`' __ \\ \\ \\ / / \\ `'__\\/'__` \\ / \\ \\ / \\ \\ \\ \\ \\ L \\ \\ / \\ \\ L \\ \\ \\ \\ / \\ \\ \\ _ \\ \\ \\ // \\ \\ L \\ . \\ _ \\ \\ \\ _ \\ \\ \\ \\ , __ / \\ \\ ____ / \\ \\ _ \\ \\ \\ __ \\\\ \\ _ \\\\ \\ __ /. \\ _ \\\\ / ` ____ \\ \\ \\ \\ / \\ / ___ / \\ / _ / \\ / __ / \\ / _ / \\ / __ / \\ / _ / ` / ___ /> \\ \\ \\ _ \\ / \\ ___ / \\ / _ / \\ / __ / Your Project with Great Documentation . Version : 1.2 . 0 Copyright Timothy Edmund Crosley 2019 MIT License View Source from portray._version import __version__ ascii_art = rf \"\"\" __ /\\ \\__ _____ ___ _ __\\ \\ ,_\\ _ __ __ __ __ /\\ '__`\\ / __`\\/\\`'__\\ \\ \\/ /\\`'__\\/'__`\\ /\\ \\/\\ \\ \\ \\ \\L\\ \\/\\ \\L\\ \\ \\ \\/ \\ \\ \\_\\ \\ \\//\\ \\L\\.\\_\\ \\ \\_\\ \\ \\ \\ ,__/\\ \\____/\\ \\_\\ \\ \\__ \\\\ \\_ \\\\ \\__/.\\_ \\\\ /`____ \\ \\ \\ \\/ \\/___/ \\/_/ \\/__/ \\/_/ \\/__/\\/_/ `/___/> \\ \\ \\_\\ /\\___/ \\/_/ \\/__/ Your Project with Great Documentation. Version: {__version__} Copyright Timothy Edmund Crosley 2019 MIT License \"\"\" __doc__ = f \"\"\" ```python {ascii_art} ``` \"\"\"","title":"Module portray.logo"},{"location":"reference/portray/logo/#variables","text":"ascii_art","title":"Variables"},{"location":"reference/portray/render/","text":"Module portray.render Defines how to render the current project and project_config using the included documentation generation utilities. View Source \"\"\"Defines how to render the current project and project_config using the included documentation generation utilities. \"\"\" import os import shutil import tempfile from argparse import Namespace from contextlib import contextmanager from glob import glob from typing import Dict import mako . exceptions import mkdocs . config as mkdocs_config import mkdocs . exceptions as _ mkdocs_exceptions from pdocs import as_markdown as pdocs_as_markdown from mkdocs . commands . build import build as mkdocs_build from portray . exceptions import DocumentationAlreadyExists NO_HOME_PAGE = \"\"\" # Nothing here `portray` uses README.md as your projects home page. It appears you do not yet have a README.md file created. \"\"\" def documentation ( config : dict , overwrite : bool = False ) -> None : \"\"\"Renders the entire project given the project config into the config's specified output directory. Behind the scenes: - A temporary directory is created and your code is copy and pasted there - pdoc is ran over your code with the output sent into the temporary directory as Markdown documents - MkDocs is ran over all of your projects Markdown documents including those generated py pdoc. MkDocs outputs an HTML representation to a new temporary directory. - The html temporary directory is copied into your specified output location - Both temporary directories are deleted. \"\"\" if os . path . exists ( config [ \"output_dir\" ]) : if overwrite : shutil . rmtree ( config [ \"output_dir\" ]) else : raise DocumentationAlreadyExists ( config [ \"output_dir\" ]) with documentation_in_temp_folder ( config ) as documentation_output: # type : str shutil . copytree ( documentation_output , config [ \"output_dir\" ]) def pdocs ( config : dict ) -> None : \"\"\"Render this project using the specified pdoc config passed into pdoc. This rendering is from code definition to Markdown so that it will be compatible with MkDocs. \"\"\" pdocs_as_markdown ( **config ) def mkdocs ( config : dict ) : \"\"\"Render the project's associated Markdown documentation using the specified MkDocs config passed into the MkDocs `build` command. This rendering is from `.md` Markdown documents into HTML \"\"\" config_instance = _ mkdocs_config ( config ) return mkdocs_build ( config_instance ) @contextmanager def documentation_in_temp_folder ( config : dict ) : \"\"\"Build documentation within a temp folder, returning that folder name before it is deleted.\"\"\" with tempfile . TemporaryDirectory () as input_dir: input_dir = os . path . join ( input_dir , \"input\" ) with tempfile . TemporaryDirectory () as temp_output_dir: shutil . copytree ( config [ \"directory\" ], input_dir ) if \"output_dir\" not in config [ \"pdocs\" ] : config [ \"pdocs\" ][ \"output_dir\" ] = os . path . join ( input_dir , \"reference\" ) pdocs ( config [ \"pdocs\" ]) if \"docs_dir\" not in config [ \"mkdocs\" ] : config [ \"mkdocs\" ][ \"docs_dir\" ] = input_dir if \"site_dir\" not in config [ \"mkdocs\" ] : config [ \"mkdocs\" ][ \"site_dir\" ] = temp_output_dir if \"nav\" not in config [ \"mkdocs\" ] : nav = config [ \"mkdocs\" ][ \"nav\" ] = [] root_docs = sorted ( glob ( os . path . join ( input_dir , \"*.md\" ))) readme_doc = os . path . join ( input_dir , \"README.md\" ) if readme_doc in root_docs: root_docs . remove ( readme_doc ) else : with open ( readme_doc , \"w\" ) as readme_doc_file: readme_doc_file . write ( NO_HOME_PAGE ) nav . append ({ \"Home\" : \"README.md\" }) nav . extend ( _ doc ( doc , input_dir , config ) for doc in root_docs ) nav . extend ( _ nested_docs ( os . path . join ( input_dir , config [ \"docs_dir\" ]), input_dir , config ) ) reference_docs = _ nested_docs ( config [ \"pdocs\" ][ \"output_dir\" ], input_dir , config ) nav . append ({ \"Reference\" : reference_docs }) # type : ignore mkdocs ( config [ \"mkdocs\" ]) yield temp_output_dir def _ mkdocs_config ( config : dict ) -> mkdocs_config . Config : config_instance = mkdocs_config . Config ( schema = mkdocs_config . DEFAULT_SCHEMA ) config_instance . load_dict ( config ) errors , warnings = config_instance . validate () if errors : print ( errors ) raise _ mkdocs_exceptions . ConfigurationError ( f \"Aborted with {len(errors)} Configuration Errors!\" ) elif config . get ( \"strict\" , False ) and warnings : print ( warnings ) raise _ mkdocs_exceptions . ConfigurationError ( f \"Aborted with {len(warnings)} Configuration Warnings in 'strict' mode!\" ) config_instance . config_file_path = config [ \"config_file_path\" ] return config_instance def _ nested_docs ( directory : str , root_directory: str , config : dict ) -> list : nav = [ _ doc ( doc , root_directory , config ) for doc in sorted ( glob ( os . path . join ( directory , \"*.md\" ))) ] nested_dirs = sorted ( glob ( os . path . join ( directory , \"*/\" ))) for nested_dir in nested_dirs: dir_nav = { _ label ( nested_dir [:- 1 ], config ) : _ nested_docs ( nested_dir , root_directory , config ) } nav . append ( dir_nav ) # type : ignore return nav def _ label ( path : str , config : Dict ) -> str : label = os . path . basename ( path ) if \".\" in label : label = \".\" . join ( label . split ( \".\" )[:- 1 ]) label = label . replace ( \"-\" , \" \" ). replace ( \"_\" , \" \" ). title () return config [ \"labels\" ]. get ( label , label ) def _ doc ( path : str , root_path: str , config : dict ) -> Dict [ str , str ] : path = os . path . relpath ( path , root_path ) return { _ label ( path , config ) : path } Variables NO_HOME_PAGE Functions documentation def documentation ( config : dict , overwrite : bool = False ) -> None Renders the entire project given the project config into the config's specified output directory. Behind the scenes: A temporary directory is created and your code is copy and pasted there pdoc is ran over your code with the output sent into the temporary directory as Markdown documents MkDocs is ran over all of your projects Markdown documents including those generated py pdoc. MkDocs outputs an HTML representation to a new temporary directory. The html temporary directory is copied into your specified output location Both temporary directories are deleted. View Source def documentation ( config : dict , overwrite : bool = False ) -> None : \"\"\" Renders the entire project given the project config into the config's specified output directory . Behind the scenes : - A temporary directory is created and your code is copy and pasted there - pdoc is ran over your code with the output sent into the temporary directory as Markdown documents - MkDocs is ran over all of your projects Markdown documents including those generated py pdoc . MkDocs outputs an HTML representation to a new temporary directory . - The html temporary directory is copied into your specified output location - Both temporary directories are deleted . \"\"\" if os . path . exists ( config [ \" output_dir \" ] ) : if overwrite : shutil . rmtree ( config [ \" output_dir \" ] ) else : raise DocumentationAlreadyExists ( config [ \" output_dir \" ] ) with documentation_in_temp_folder ( config ) as documentation_output : # type : str shutil . copytree ( documentation_output , config [ \" output_dir \" ] ) documentation_in_temp_folder def documentation_in_temp_folder ( config : dict ) Build documentation within a temp folder, returning that folder name before it is deleted. View Source @ contextmanager def documentation_in_temp_folder ( config : dict ) : \"\"\" Build documentation within a temp folder, returning that folder name before it is deleted. \"\"\" with tempfile . TemporaryDirectory () as input_dir : input_dir = os . path . join ( input_dir , \" input \" ) with tempfile . TemporaryDirectory () as temp_output_dir : shutil . copytree ( config [ \" directory \" ], input_dir ) if \" output_dir \" not in config [ \" pdocs \" ]: config [ \" pdocs \" ][ \" output_dir \" ] = os . path . join ( input_dir , \" reference \" ) pdocs ( config [ \" pdocs \" ] ) if \" docs_dir \" not in config [ \" mkdocs \" ]: config [ \" mkdocs \" ][ \" docs_dir \" ] = input_dir if \" site_dir \" not in config [ \" mkdocs \" ]: config [ \" mkdocs \" ][ \" site_dir \" ] = temp_output_dir if \" nav \" not in config [ \" mkdocs \" ]: nav = config [ \" mkdocs \" ][ \" nav \" ] = [] root_docs = sorted ( glob ( os . path . join ( input_dir , \" *.md \" ))) readme_doc = os . path . join ( input_dir , \" README.md \" ) if readme_doc in root_docs : root_docs . remove ( readme_doc ) else : with open ( readme_doc , \" w \" ) as readme_doc_file : readme_doc_file . write ( NO_HOME_PAGE ) nav . append ( { \" Home \" : \" README.md \" } ) nav . extend ( _doc ( doc , input_dir , config ) for doc in root_docs ) nav . extend ( _nested_docs ( os . path . join ( input_dir , config [ \" docs_dir \" ] ) , input_dir , config ) ) reference_docs = _nested_docs ( config [ \" pdocs \" ][ \" output_dir \" ], input_dir , config ) nav . append ( { \" Reference \" : reference_docs } ) # type : ignore mkdocs ( config [ \" mkdocs \" ] ) yield temp_output_dir mkdocs def mkdocs ( config : dict ) Render the project's associated Markdown documentation using the specified MkDocs config passed into the MkDocs build command. This rendering is from .md Markdown documents into HTML View Source def mkdocs ( config : dict ) : \"\"\" Render the project's associated Markdown documentation using the specified MkDocs config passed into the MkDocs ` build ` command . This rendering is from `. md ` Markdown documents into HTML \"\"\" config_instance = _mkdocs_config ( config ) return mkdocs_build ( config_instance ) pdocs def pdocs ( config : dict ) -> None Render this project using the specified pdoc config passed into pdoc. This rendering is from code definition to Markdown so that it will be compatible with MkDocs. View Source def pdocs ( config : dict ) -> None : \"\"\"Render this project using the specified pdoc config passed into pdoc. This rendering is from code definition to Markdown so that it will be compatible with MkDocs. \"\"\" pdocs_as_markdown ( ** config )","title":"Render"},{"location":"reference/portray/render/#module-portrayrender","text":"Defines how to render the current project and project_config using the included documentation generation utilities. View Source \"\"\"Defines how to render the current project and project_config using the included documentation generation utilities. \"\"\" import os import shutil import tempfile from argparse import Namespace from contextlib import contextmanager from glob import glob from typing import Dict import mako . exceptions import mkdocs . config as mkdocs_config import mkdocs . exceptions as _ mkdocs_exceptions from pdocs import as_markdown as pdocs_as_markdown from mkdocs . commands . build import build as mkdocs_build from portray . exceptions import DocumentationAlreadyExists NO_HOME_PAGE = \"\"\" # Nothing here `portray` uses README.md as your projects home page. It appears you do not yet have a README.md file created. \"\"\" def documentation ( config : dict , overwrite : bool = False ) -> None : \"\"\"Renders the entire project given the project config into the config's specified output directory. Behind the scenes: - A temporary directory is created and your code is copy and pasted there - pdoc is ran over your code with the output sent into the temporary directory as Markdown documents - MkDocs is ran over all of your projects Markdown documents including those generated py pdoc. MkDocs outputs an HTML representation to a new temporary directory. - The html temporary directory is copied into your specified output location - Both temporary directories are deleted. \"\"\" if os . path . exists ( config [ \"output_dir\" ]) : if overwrite : shutil . rmtree ( config [ \"output_dir\" ]) else : raise DocumentationAlreadyExists ( config [ \"output_dir\" ]) with documentation_in_temp_folder ( config ) as documentation_output: # type : str shutil . copytree ( documentation_output , config [ \"output_dir\" ]) def pdocs ( config : dict ) -> None : \"\"\"Render this project using the specified pdoc config passed into pdoc. This rendering is from code definition to Markdown so that it will be compatible with MkDocs. \"\"\" pdocs_as_markdown ( **config ) def mkdocs ( config : dict ) : \"\"\"Render the project's associated Markdown documentation using the specified MkDocs config passed into the MkDocs `build` command. This rendering is from `.md` Markdown documents into HTML \"\"\" config_instance = _ mkdocs_config ( config ) return mkdocs_build ( config_instance ) @contextmanager def documentation_in_temp_folder ( config : dict ) : \"\"\"Build documentation within a temp folder, returning that folder name before it is deleted.\"\"\" with tempfile . TemporaryDirectory () as input_dir: input_dir = os . path . join ( input_dir , \"input\" ) with tempfile . TemporaryDirectory () as temp_output_dir: shutil . copytree ( config [ \"directory\" ], input_dir ) if \"output_dir\" not in config [ \"pdocs\" ] : config [ \"pdocs\" ][ \"output_dir\" ] = os . path . join ( input_dir , \"reference\" ) pdocs ( config [ \"pdocs\" ]) if \"docs_dir\" not in config [ \"mkdocs\" ] : config [ \"mkdocs\" ][ \"docs_dir\" ] = input_dir if \"site_dir\" not in config [ \"mkdocs\" ] : config [ \"mkdocs\" ][ \"site_dir\" ] = temp_output_dir if \"nav\" not in config [ \"mkdocs\" ] : nav = config [ \"mkdocs\" ][ \"nav\" ] = [] root_docs = sorted ( glob ( os . path . join ( input_dir , \"*.md\" ))) readme_doc = os . path . join ( input_dir , \"README.md\" ) if readme_doc in root_docs: root_docs . remove ( readme_doc ) else : with open ( readme_doc , \"w\" ) as readme_doc_file: readme_doc_file . write ( NO_HOME_PAGE ) nav . append ({ \"Home\" : \"README.md\" }) nav . extend ( _ doc ( doc , input_dir , config ) for doc in root_docs ) nav . extend ( _ nested_docs ( os . path . join ( input_dir , config [ \"docs_dir\" ]), input_dir , config ) ) reference_docs = _ nested_docs ( config [ \"pdocs\" ][ \"output_dir\" ], input_dir , config ) nav . append ({ \"Reference\" : reference_docs }) # type : ignore mkdocs ( config [ \"mkdocs\" ]) yield temp_output_dir def _ mkdocs_config ( config : dict ) -> mkdocs_config . Config : config_instance = mkdocs_config . Config ( schema = mkdocs_config . DEFAULT_SCHEMA ) config_instance . load_dict ( config ) errors , warnings = config_instance . validate () if errors : print ( errors ) raise _ mkdocs_exceptions . ConfigurationError ( f \"Aborted with {len(errors)} Configuration Errors!\" ) elif config . get ( \"strict\" , False ) and warnings : print ( warnings ) raise _ mkdocs_exceptions . ConfigurationError ( f \"Aborted with {len(warnings)} Configuration Warnings in 'strict' mode!\" ) config_instance . config_file_path = config [ \"config_file_path\" ] return config_instance def _ nested_docs ( directory : str , root_directory: str , config : dict ) -> list : nav = [ _ doc ( doc , root_directory , config ) for doc in sorted ( glob ( os . path . join ( directory , \"*.md\" ))) ] nested_dirs = sorted ( glob ( os . path . join ( directory , \"*/\" ))) for nested_dir in nested_dirs: dir_nav = { _ label ( nested_dir [:- 1 ], config ) : _ nested_docs ( nested_dir , root_directory , config ) } nav . append ( dir_nav ) # type : ignore return nav def _ label ( path : str , config : Dict ) -> str : label = os . path . basename ( path ) if \".\" in label : label = \".\" . join ( label . split ( \".\" )[:- 1 ]) label = label . replace ( \"-\" , \" \" ). replace ( \"_\" , \" \" ). title () return config [ \"labels\" ]. get ( label , label ) def _ doc ( path : str , root_path: str , config : dict ) -> Dict [ str , str ] : path = os . path . relpath ( path , root_path ) return { _ label ( path , config ) : path }","title":"Module portray.render"},{"location":"reference/portray/render/#variables","text":"NO_HOME_PAGE","title":"Variables"},{"location":"reference/portray/render/#functions","text":"","title":"Functions"},{"location":"reference/portray/render/#documentation","text":"def documentation ( config : dict , overwrite : bool = False ) -> None Renders the entire project given the project config into the config's specified output directory. Behind the scenes: A temporary directory is created and your code is copy and pasted there pdoc is ran over your code with the output sent into the temporary directory as Markdown documents MkDocs is ran over all of your projects Markdown documents including those generated py pdoc. MkDocs outputs an HTML representation to a new temporary directory. The html temporary directory is copied into your specified output location Both temporary directories are deleted. View Source def documentation ( config : dict , overwrite : bool = False ) -> None : \"\"\" Renders the entire project given the project config into the config's specified output directory . Behind the scenes : - A temporary directory is created and your code is copy and pasted there - pdoc is ran over your code with the output sent into the temporary directory as Markdown documents - MkDocs is ran over all of your projects Markdown documents including those generated py pdoc . MkDocs outputs an HTML representation to a new temporary directory . - The html temporary directory is copied into your specified output location - Both temporary directories are deleted . \"\"\" if os . path . exists ( config [ \" output_dir \" ] ) : if overwrite : shutil . rmtree ( config [ \" output_dir \" ] ) else : raise DocumentationAlreadyExists ( config [ \" output_dir \" ] ) with documentation_in_temp_folder ( config ) as documentation_output : # type : str shutil . copytree ( documentation_output , config [ \" output_dir \" ] )","title":"documentation"},{"location":"reference/portray/render/#documentation_in_temp_folder","text":"def documentation_in_temp_folder ( config : dict ) Build documentation within a temp folder, returning that folder name before it is deleted. View Source @ contextmanager def documentation_in_temp_folder ( config : dict ) : \"\"\" Build documentation within a temp folder, returning that folder name before it is deleted. \"\"\" with tempfile . TemporaryDirectory () as input_dir : input_dir = os . path . join ( input_dir , \" input \" ) with tempfile . TemporaryDirectory () as temp_output_dir : shutil . copytree ( config [ \" directory \" ], input_dir ) if \" output_dir \" not in config [ \" pdocs \" ]: config [ \" pdocs \" ][ \" output_dir \" ] = os . path . join ( input_dir , \" reference \" ) pdocs ( config [ \" pdocs \" ] ) if \" docs_dir \" not in config [ \" mkdocs \" ]: config [ \" mkdocs \" ][ \" docs_dir \" ] = input_dir if \" site_dir \" not in config [ \" mkdocs \" ]: config [ \" mkdocs \" ][ \" site_dir \" ] = temp_output_dir if \" nav \" not in config [ \" mkdocs \" ]: nav = config [ \" mkdocs \" ][ \" nav \" ] = [] root_docs = sorted ( glob ( os . path . join ( input_dir , \" *.md \" ))) readme_doc = os . path . join ( input_dir , \" README.md \" ) if readme_doc in root_docs : root_docs . remove ( readme_doc ) else : with open ( readme_doc , \" w \" ) as readme_doc_file : readme_doc_file . write ( NO_HOME_PAGE ) nav . append ( { \" Home \" : \" README.md \" } ) nav . extend ( _doc ( doc , input_dir , config ) for doc in root_docs ) nav . extend ( _nested_docs ( os . path . join ( input_dir , config [ \" docs_dir \" ] ) , input_dir , config ) ) reference_docs = _nested_docs ( config [ \" pdocs \" ][ \" output_dir \" ], input_dir , config ) nav . append ( { \" Reference \" : reference_docs } ) # type : ignore mkdocs ( config [ \" mkdocs \" ] ) yield temp_output_dir","title":"documentation_in_temp_folder"},{"location":"reference/portray/render/#mkdocs","text":"def mkdocs ( config : dict ) Render the project's associated Markdown documentation using the specified MkDocs config passed into the MkDocs build command. This rendering is from .md Markdown documents into HTML View Source def mkdocs ( config : dict ) : \"\"\" Render the project's associated Markdown documentation using the specified MkDocs config passed into the MkDocs ` build ` command . This rendering is from `. md ` Markdown documents into HTML \"\"\" config_instance = _mkdocs_config ( config ) return mkdocs_build ( config_instance )","title":"mkdocs"},{"location":"reference/portray/render/#pdocs","text":"def pdocs ( config : dict ) -> None Render this project using the specified pdoc config passed into pdoc. This rendering is from code definition to Markdown so that it will be compatible with MkDocs. View Source def pdocs ( config : dict ) -> None : \"\"\"Render this project using the specified pdoc config passed into pdoc. This rendering is from code definition to Markdown so that it will be compatible with MkDocs. \"\"\" pdocs_as_markdown ( ** config )","title":"pdocs"}]}